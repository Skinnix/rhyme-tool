@namespace Skinnix.RhymeTool.Client.Components.Editing

@using Skinnix.RhymeTool.ComponentModel
@using Skinnix.RhymeTool.Data
@using Skinnix.RhymeTool.Data.Notation
@using Skinnix.RhymeTool.Data.Notation.Display

@implements IAsyncDisposable

@inject IJSRuntime js

<div class="chord-sheet chord-sheet-editor chord-sheet-editing" contenteditable="true" @ref="editorWrapper"
     spellcheck="false" enterkeyhint="enter">
    @if (Document != null)
    {
        <CascadingValue TValue="ISheetEditorFormatter" Value="Formatter">
            <CascadingValue TValue="SheetDocument" Value="Document">

                @foreach (var line in Document.Lines){<SheetEditorLine Line="line" @key="line" OnLinesRendered="OnLinesRendered" />}

            </CascadingValue>
        </CascadingValue>
    }

    <RerenderAnchor @ref="rerenderAnchor" />
</div>

@code {
    public static readonly Reason UnknownEditType = new("Unbekannter Bearbeitungstyp");
    public static readonly Reason MultilineEditNotSupported = new("Mehrzeilige Bearbeitung wird noch nicht unterstützt");
    public static readonly Reason LineNotFound = new("Zeile nicht gefunden");

    [Parameter] public SheetDocument? Document { get; set; }
    [Parameter] public ISheetEditorFormatter? Formatter { get; set; }

    private SheetDocument? loadedDocument;
    private ISheetEditorFormatter? loadedFormatter;

    private ElementReference editorWrapper;
    private RerenderAnchor rerenderAnchor = null!;
    private IJSObjectReference? jsEditor = null;

    private bool shouldRender;

    private readonly WeakDictionary<Guid, SheetDisplayLine[]> renderedLines = new();

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (Document != loadedDocument)
        {
            shouldRender = true;

            if (loadedDocument is not null)
                loadedDocument.Lines.Modified -= OnLinesModified;

            renderedLines.Clear();
            loadedDocument = Document;

            if (loadedDocument is not null)
                loadedDocument.Lines.Modified += OnLinesModified;
        }

        if (Formatter != loadedFormatter)
        {
            shouldRender = true;

            loadedFormatter = Formatter;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            jsEditor = await js.InvokeAsync<IJSObjectReference>("registerChordEditor", editorWrapper, DotNetObjectReference.Create(this), nameof(OnBeforeInput));
            //rerenderAnchor.BeforeRender = () => reference.InvokeVoidAsync("notifyBeforeRender");
            rerenderAnchor.AfterRender = () => jsEditor.InvokeVoidAsync("notifyAfterRender");
        }

        //await js.InvokeVoidAsync("notifyRenderFinished", this.GetType().Name);
        shouldRender = false;
    }

    public async ValueTask DisposeAsync()
    {
        if (jsEditor is not null)
        {
            await jsEditor.InvokeVoidAsync("destroy");
            await jsEditor.DisposeAsync();
            jsEditor = null;
        }
    }

    protected override bool ShouldRender()
    {
        if (!shouldRender)
            return false;

        return true;
    }

    private new void StateHasChanged()
    {
        shouldRender = true;
        base.StateHasChanged();
    }

    private void OnLinesModified(object? sender, ModifiedEventArgs args)
        => StateHasChanged();

    private void OnLinesRendered(SheetDisplayLine[] lines)
    {
        if (lines.Length == 0)
            return;

        var lineGuid = lines[0].Editing.Line.Guid;
        renderedLines[lineGuid] = lines;
    }
}