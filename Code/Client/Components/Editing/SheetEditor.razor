@namespace Skinnix.RhymeTool.Client.Components.Editing

@using Skinnix.RhymeTool.ComponentModel
@using Skinnix.RhymeTool.Data
@using Skinnix.RhymeTool.Data.Notation
@using Skinnix.RhymeTool.Data.Notation.Display

@inject IJSRuntime js

<div class="chord-sheet chord-sheet-editor chord-sheet-editing" contenteditable @ref="editorWrapper"
     spellcheck="false" enterkeyhint="enter">
    @if (Document != null)
    {
        <CascadingValue TValue="ISheetEditorFormatter" Value="Formatter">
            <CascadingValue TValue="SheetDocument" Value="Document">

                @foreach (var line in Document.Lines){<SheetEditorLine Line="line" @key="line" @ref="lineEditorsSetter" />}

            </CascadingValue>
        </CascadingValue>
    }
</div>

@code {
    public static readonly Reason UnknownEditType = new("Unbekannter Bearbeitungstyp");
    public static readonly Reason MultilineEditNotSupported = new("Mehrzeilige Bearbeitung wird noch nicht unterstützt");
    public static readonly Reason LineNotFound = new("Zeile nicht gefunden");

    [Parameter] public SheetDocument? Document { get; set; }
    [Parameter] public ISheetEditorFormatter? Formatter { get; set; }

    private SheetDocument? loadedDocument;
    private ISheetEditorFormatter? loadedFormatter;

    private ElementReference editorWrapper;

    private bool shouldRender;

    private readonly WeakDictionary<Guid, SheetEditorLine> lineEditors = new();
    private SheetEditorLine lineEditorsSetter
    {
        set
        {
            if (value.Line != null)
                lineEditors[value.Line.Guid] = value;
        }
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (Document != loadedDocument)
        {
            shouldRender = true;

            if (loadedDocument is not null)
                loadedDocument.Lines.Modified -= OnLinesModified;

            lineEditors.Clear();
            loadedDocument = Document;

            if (loadedDocument is not null)
                loadedDocument.Lines.Modified += OnLinesModified;
        }

        if (Formatter != loadedFormatter)
        {
            shouldRender = true;

            loadedFormatter = Formatter;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            await js.InvokeVoidAsync("registerBeforeInput", editorWrapper, DotNetObjectReference.Create(this), nameof(OnBeforeInput));
        }

        await js.InvokeVoidAsync("console.log", "rerender: " + this.GetType().Name);
        shouldRender = false;
    }

    protected override bool ShouldRender()
    {
        if (!shouldRender)
            return false;

        return true;
    }

    private new void StateHasChanged()
    {
        shouldRender = true;
        base.StateHasChanged();
    }

    private void OnLinesModified(object? sender, ModifiedEventArgs args)
        => StateHasChanged();
}