@namespace Skinnix.RhymeTool.Client.Components.Editing

@using Skinnix.RhymeTool.ComponentModel
@using Skinnix.RhymeTool.Data
@using Skinnix.RhymeTool.Data.Notation
@using Skinnix.RhymeTool.Data.Notation.Display
@using Skinnix.RhymeTool.Data.Notation.Display.Caching

@inject IJSRuntime js

@{
    void RenderNote(Note note, bool isBassNote = false)
    {
        var format = (isBassNote ? Formatter?.FormatBassNote(note) : Formatter?.FormatNote(note))
            ?? (note.Accidental == AccidentalType.None ? new(note.Type.GetDisplayName())
            : new(note.Type.GetDisplayName(), note.Accidental.GetDisplayName()));

        @(format.Type)

        <span class="accidental">@format.Accidental</span>
    }

    void RenderChord(Chord chord)
    {
        <span class="chord">
            <span class="chord-root">@{
                    RenderNote(chord.Root);
                }</span><span class="chord-quality">@chord.Quality.ToString(Formatter)</span>

            @if (chord.Alterations.Count > 0)
            {
                var firstAlteration = true;
                <span class="chord-alterations">
                    @foreach (var alteration in chord.Alterations)
                    {
                        if (!firstAlteration)
                        {
                            <span class="chord-alteration-separator">/</span>
                        }
                        firstAlteration = false;

                        <span class="chord-alteration">@alteration.ToString(Formatter)</span>
                    }
                </span>
            }

            @if (chord.Bass != null)
            {
                <span class="chord-bass-separator">/</span>

                <span class="chord-bass">@{ RenderNote(chord.Bass.Value, true); }</span>
            }
        </span>
    }

    void RenderElement(SheetDisplayLineElement element)
    {
        switch (element)
        {
            case SheetDisplayLineFormatSpace formatSpace:
                <span class="format-space">@formatSpace.ToString(Formatter)</span>
                break;

            case SheetDisplayLineSpace space:
                <span class="space">@space.ToString(Formatter)</span>
                break;

            case SheetDisplayLineChord chord:
                RenderChord(chord.Chord);
                break;

            case SheetDisplayLineText text:
                <span class="text">@text.ToString(Formatter)</span>
                break;

            case SheetDisplayLineAnchorText anchorText:
                <span class="anchor-text">@anchorText.ToString(Formatter)</span>
                break;

            case SheetDisplayLineSegmentTitleBracket titleBracket:
                <span class="segment-title-bracket">@titleBracket.ToString(Formatter)</span>
                break;

            case SheetDisplayLineSegmentTitleText titleText:
                <span class="segment-title" id="sheetSegment-@(Line?.Guid)">@titleText.ToString(Formatter)</span>
                break;

            case SheetDisplayLineHyphen hyphen:
                <span class="hyphen">@hyphen.ToString(Formatter)</span>
                break;
        }
    }

    void RenderElements(IEnumerable<SheetDisplayLineElement> elements)
    {
        foreach (var element in elements)
            RenderElement(element);
    }

    void RenderLine(SheetDisplayLine line)
    {
        switch (line)
        {
            case SheetDisplayEmptyLine empty:
                <div class="line line-empty" data-line-index="@line.Id"></div>
                break;

            case SheetDisplayChordLine chords:
                <div class="line line-chords" data-line-index="@line.Id">@{RenderElements(line.GetElements());}</div>
                break;

            case SheetDisplayTextLine text:
                <div class="line line-text" data-line-index="@line.Id">@{RenderElements(line.GetElements());}</div>
                break;
        }
    }
}

@if (Line is not null)
{
    <span class="metaline" data-metaline="@(Line.Guid)" data-type="@Line.GetType()?.Name">
        <span class="metaline-controls" contenteditable="false">@*<MetalineTypeButton Line="Line" />*@</span><span class="metaline-lines">
            @foreach (var display in Line.CreateDisplayLines(Formatter))
            {
                <span @key="display" class="line-controls" contenteditable="false"><LineTypeButton Line="display" /></span>
                RenderLine(display);
            }
        </span>
    </span>
}

@code {
    [CascadingParameter] public SheetDocument? Document { get; set; }
    [CascadingParameter] public ISheetEditorFormatter? Formatter { get; set; }

    [Parameter] public SheetLine? Line { get; set; }

    private SheetLine? loadedLine;
    private bool shouldRender;

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        if (Line != loadedLine)
        {
            shouldRender = true;

            if (loadedLine is not null)
                loadedLine.Modified -= OnLineModified;

            loadedLine = Line;

            if (loadedLine is not null)
                loadedLine.Modified += OnLineModified;
        }
    }

    protected override bool ShouldRender()
    {
        return shouldRender;
    }

    private new void StateHasChanged()
    {
        shouldRender = true;
        base.StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        shouldRender = false;

        await base.OnAfterRenderAsync(firstRender);

        await js.InvokeVoidAsync("console.log", "rerender: " + this.GetType().Name);
    }

    private void OnLineModified(object? sender, ModifiedEventArgs args)
    {
        StateHasChanged();
    }

    public MetalineEditResult HandleInput(InputEventData data)
    {
        if (Line is null || Document is null) throw new InvalidOperationException("Editor not initialized");

        //find lines
        var lines = Line.CreateDisplayLines(Formatter);
        var startLine = lines.FirstOrDefault(l => l.Id == data.Selection.Start.Line);
        var endLine = lines.FirstOrDefault(l => l.Id == data.Selection.End.Line);

        if (startLine is null || endLine is null || startLine != endLine)
        {
            return null; //TODO: for now, we don't support multiline editing
        }

        //selection range
        var selectionRange = new SimpleRange(data.Selection.Start.Offset, data.Selection.End.Offset);
        var context = new SheetDisplayLineEditingContext(selectionRange)
        {
            GetLineBefore = () => Document.Lines.GetLineBefore(Line),
            GetLineAfter = () => Document.Lines.GetLineAfter(Line),
        };

        MetalineEditResult? editResult = null;
        switch (data.InputType)
        {
            case "insertFromDrop":
            case "insertFromPaste":
            case "insertFromPasteAsQuotation":
            case "insertLink":
            case "insertText":
                editResult = startLine.Editing.InsertContent(context, data.Data, Formatter);
                _ = js.InvokeVoidAsync("console.log", "insert: " + data.InputType);
                break;
            case "insertLineBreak":
            case "insertParagraph":
                editResult = startLine.Editing.InsertContent(context, "\n", Formatter);
                _ = js.InvokeVoidAsync("console.log", "line break: " + data.InputType);
                break;
            case "deleteByCut":
            case "deleteByDrag":
            case "deleteContentBackward":
            case "deleteContent":
                editResult = startLine.Editing.DeleteContent(context, false, Formatter);
                break;
            case "deleteContentForward":
                editResult = startLine.Editing.DeleteContent(context, true, Formatter);
                break;
            default:
                _ = js.InvokeVoidAsync("console.log", "unknown: " + data.InputType);
                break;
        }

        if (editResult == null)
            return MetalineEditResult.Fail(SheetEditor.UnknownEditType);

        if (!editResult.Success)
            return editResult;

        //Füge ggf. Zeilen hinzu oder entferne sie
        Document.Lines.InsertAndRemove(Line, editResult.RemoveLine, editResult.RemoveLineBefore, editResult.RemoveLineAfter,
            editResult.InsertLinesBefore, editResult.InsertLinesAfter);

        StateHasChanged();
        return editResult;
    }

    private MetalineType GetEffectiveType(IReadOnlyList<SheetDisplayLine> displayLines)
    {
        if (displayLines.Count == 0)
            return MetalineType.Unknown;

        var type = MetalineType.Unknown;
        foreach (var display in displayLines)
        {
            switch (display)
            {
                case SheetDisplayChordLine:
                    type |= MetalineType.Chords;
                    break;
                case SheetDisplayTextLine:
                    type |= MetalineType.Text;
                    break;
            }
        }

        return type;
    }

    private enum MetalineType
    {
        Unknown = 0,
        Text = 1,
        Chords = 2,
        TextAndChords = Text | Chords,
    }
}